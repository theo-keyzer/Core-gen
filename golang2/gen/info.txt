// Previous code remains except for Kp-related definitions...

// Kp defines the interface for key-path operations
type Kp interface {
	DoIts(glob *GlobT, va []string, lno string) int
	GetVar(glob *GlobT, va []string, lno string) []interface{}
	GetMe() int
	GetComp() string
	GetLineNo() string
	GetFlags() []string
	GetNames() map[string]interface{}
}

// BaseKp provides a base implementation of the Kp interface
type BaseKp struct {
	me      int
	comp    string
	lineNo  string
	flags   []string
	names   map[string]interface{}
}

// NewBaseKp creates a new BaseKp instance with default values
func NewBaseKp() *BaseKp {
	return &BaseKp{
		me:     -1,
		comp:   "Kp",
		lineNo: "",
		flags:  make([]string, 0),
		names:  make(map[string]interface{}),
	}
}

// Implementation of Kp interface for BaseKp
func (k *BaseKp) DoIts(glob *GlobT, va []string, lno string) int {
	fmt.Printf("?No its %s cmd for Kp,%s?\n", va[0], lno)
	return 0
}

func (k *BaseKp) GetVar(glob *GlobT, va []string, lno string) []interface{} {
	if v, ok := k.names[va[0]]; ok {
		return []interface{}{true, v}
	}
	return []interface{}{false, fmt.Sprintf("?%s?%s,%s,Kp?", va[0], k.lineNo, lno)}
}

func (k *BaseKp) GetMe() int                           { return k.me }
func (k *BaseKp) GetComp() string                      { return k.comp }
func (k *BaseKp) GetLineNo() string                    { return k.lineNo }
func (k *BaseKp) GetFlags() []string                   { return k.flags }
func (k *BaseKp) GetNames() map[string]interface{}     { return k.names }

// KpActor implements the Kp interface
type KpActor struct {
	*BaseKp
	kName  string
	kComp  string
	kAttr  string
	kEq    string
	kValue string
	childs []Kp
}

// NewKpActor creates a new KpActor instance
func NewKpActor() *KpActor {
	return &KpActor{
		BaseKp: NewBaseKp(),
		childs: make([]Kp, 0),
	}
}

// Override DoIts for KpActor if needed
func (ka *KpActor) DoIts(glob *GlobT, va []string, lno string) int {
	// KpActor-specific implementation
	return ka.BaseKp.DoIts(glob, va, lno)
}

// Load implements the loading functionality for KpActor
func (ka *KpActor) Load(act *Acts, ln string, pos int, lno string, flag []string) bool {
	ka.comp = "Actor"
	ka.lineNo = lno
	ka.flags = flag
	ka.me = len(act.ApActor)

	// Parse k_name
	var tok []interface{}
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.kName = tok[1].(string)

	// Parse k_comp
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.kComp = tok[1].(string)

	// Parse k_attr
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.kAttr = tok[1].(string)

	// Parse k_eq
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.kEq = tok[1].(string)

	// Parse k_value
	tok = getws(ln, pos)
	ka.kValue = tok[1].(string)

	// Add to index
	act.Index["Actor_"+ka.kName] = ka.me

	return true
}

// Getter methods for KpActor-specific fields
func (ka *KpActor) GetKName() string  { return ka.kName }
func (ka *KpActor) GetKComp() string  { return ka.kComp }
func (ka *KpActor) GetKAttr() string  { return ka.kAttr }
func (ka *KpActor) GetKEq() string    { return ka.kEq }
func (ka *KpActor) GetKValue() string { return ka.kValue }
func (ka *KpActor) GetChilds() []Kp   { return ka.childs }

// Acts represents the collection of actors and their index
type Acts struct {
	ApActor []*KpActor
	Index   map[string]interface{}
}

func NewActs() *Acts {
	return &Acts{
		ApActor: make([]*KpActor, 0),
		Index:   make(map[string]interface{}),
	}
}

// Update related functions to use the interface
func getPath(glob *GlobT, winp int, va []string, lno string) Record {
	// Update type assertions to use the interface
	if kp, ok := glob.wins[winp].Dat.(Kp); ok {
		// Use interface methods
		return Record{
			Ok:   true,
			Dat:  fmt.Sprintf("%s, %s", kp.GetLineNo(), lno),
			Path: []string{},
		}
	}
	// Rest of the function remains the same...
	return Record{}
}
===============================

// Previous code remains the same...

// Kp represents the base key-path structure
type Kp struct {
	Me      int
	Comp    string
	LineNo  string
	Flags   []string
	Names   map[string]interface{}
}

// NewKp creates a new Kp instance with default values
func NewKp() *Kp {
	return &Kp{
		Me:      -1,
		Comp:    "Kp",
		LineNo:  "",
		Flags:   make([]string, 0),
		Names:   make(map[string]interface{}),
	}
}

// DoIts is the default implementation for Kp
func (k *Kp) DoIts(glob *GlobT, va []string, lno string) int {
	fmt.Printf("?No its %s cmd for Kp,%s?\n", va[0], lno)
	return 0
}

// GetVar retrieves a variable from the Names map
func (k *Kp) GetVar(glob *GlobT, va []string, lno string) []interface{} {
	if v, ok := k.Names[va[0]]; ok {
		return []interface{}{true, v}
	}
	return []interface{}{false, fmt.Sprintf("?%s?%s,%s,Kp?", va[0], k.LineNo, lno)}
}

// KpActor extends Kp for actor-specific functionality
type KpActor struct {
	Kp
	KName  string
	KComp  string
	KAttr  string
	KEq    string
	KValue string
	Childs []*Kp
}

// NewKpActor creates a new KpActor instance
func NewKpActor() *KpActor {
	return &KpActor{
		Kp:     *NewKp(),
		Childs: make([]*Kp, 0),
	}
}

// Acts represents the collection of actors and their index
type Acts struct {
	ApActor []*KpActor
	Index   map[string]interface{}
}

// Load implements the loading functionality for KpActor
func (ka *KpActor) Load(act *Acts, ln string, pos int, lno string, flag []string) bool {
	ka.Comp = "Actor"
	ka.LineNo = lno
	ka.Flags = flag
	ka.Me = len(act.ApActor)

	// Parse k_name
	var tok []interface{}
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.KName = tok[1].(string)

	// Parse k_comp
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.KComp = tok[1].(string)

	// Parse k_attr
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.KAttr = tok[1].(string)

	// Parse k_eq
	tok = getw(ln, pos)
	pos = tok[0].(int)
	ka.KEq = tok[1].(string)

	// Parse k_value
	tok = getws(ln, pos)
	ka.KValue = tok[1].(string)

	// Add to index
	act.Index["Actor_"+ka.KName] = ka.Me

	return true
}

// Helper function to initialize Acts
func NewActs() *Acts {
	return &Acts{
		ApActor: make([]*KpActor, 0),
		Index:   make(map[string]interface{}),
	}
}

// Update GlobT to include new fields
type GlobT struct {
	Acts     *Acts
	Dats     interface{}
	LoadErrs bool
	RunErrs  bool
	Buffer   strings.Builder
	Wins     []*Window
	Winp     int
	Collect  interface{}
	Ins      interface{}
}

// Initialize a new GlobT
func NewGlobT() *GlobT {
	return &GlobT{
		Acts:     NewActs(),
		LoadErrs: false,
		RunErrs:  false,
		Wins:     make([]*Window, 0),
		Buffer:   strings.Builder{},
	}
}
